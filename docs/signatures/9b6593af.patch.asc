-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- From 9b6593afafda0999cf805b8033ee3637beb03f1b Mon Sep 17 00:00:00 2001
From: Sebastian Bach <sebtomba@gmail.com>
Date: Wed, 24 May 2023 19:59:26 +0200
Subject: [PATCH] [PM-6226] Extract the Midnight ledger bridge into a separate
 subproject

- ---
 Cargo.lock                            |  18 +++-
 Cargo.toml                            |   1 +
 ledger/Cargo.toml                     |  14 +++
 ledger/src/lib.rs                     | 117 ++++++++++++++++++++++++++
 pallets/midnight/Cargo.toml           |   1 +
 pallets/midnight/src/ledger_bridge.rs | 117 --------------------------
 pallets/midnight/src/lib.rs           |  13 ++-
 7 files changed, 155 insertions(+), 126 deletions(-)
 create mode 100644 ledger/Cargo.toml
 create mode 100644 ledger/src/lib.rs
 delete mode 100644 pallets/midnight/src/ledger_bridge.rs

diff --git a/Cargo.lock b/Cargo.lock
index 514f5e2d..6bf56abc 100644
- --- a/Cargo.lock
+++ b/Cargo.lock
@@ -4539,6 +4539,19 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "midnight-ledger"
+version = "0.1.0"
+dependencies = [
+ "ciborium",
+ "hex",
+ "midnight-base-crypto",
+ "midnight-coin-structure",
+ "midnight-lares-compitales",
+ "midnight-ledger 2.0.0-pre-0.1",
+ "serde_json",
+]
+
 [[package]]
 name = "midnight-ledger"
 version = "2.0.0-pre-0.1"
@@ -4573,7 +4586,7 @@ dependencies = [
  "jsonrpsee",
  "midnight-base-crypto",
  "midnight-lares-compitales",
- - "midnight-ledger",
+ "midnight-ledger 2.0.0-pre-0.1",
  "midnight-node-runtime",
  "midnight-storage",
  "pallet-transaction-payment",
@@ -5251,7 +5264,8 @@ dependencies = [
  "midnight-base-crypto",
  "midnight-coin-structure",
  "midnight-lares-compitales",
- - "midnight-ledger",
+ "midnight-ledger 0.1.0",
+ "midnight-ledger 2.0.0-pre-0.1",
  "parity-scale-codec",
  "scale-info",
  "serde_json",
diff --git a/Cargo.toml b/Cargo.toml
index 2a02eb4c..f39eeb7b 100644
- --- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,5 +1,6 @@
 [workspace]
 members = [
+    "ledger",
     "node",
     "pallets/midnight",
     "runtime",
diff --git a/ledger/Cargo.toml b/ledger/Cargo.toml
new file mode 100644
index 00000000..8ca85258
- --- /dev/null
+++ b/ledger/Cargo.toml
@@ -0,0 +1,14 @@
+[package]
+name = "midnight-ledger"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+ledger = { git = "https://github.com/input-output-hk/midnight-ledger-prototype", package = "midnight-ledger", features = ["transaction-construction", "proving"] }
+lares-compitales = { git = "https://github.com/input-output-hk/abcirdc", package = "midnight-lares-compitales" }
+midnight-base-crypto = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-base-crypto", features = ["fake"] }
+coin-structure = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-coin-structure", features = ["fake"] }
+
+ciborium = { version = "0.2.0" }
+serde_json = { version = "1.0" }
+hex = { version = "0.4.3" }
diff --git a/ledger/src/lib.rs b/ledger/src/lib.rs
new file mode 100644
index 00000000..0e491503
- --- /dev/null
+++ b/ledger/src/lib.rs
@@ -0,0 +1,117 @@
+use ciborium::{de, ser};
+use coin_structure::contract::Address as ContractAddress;
+use hex::encode;
+use ledger::structure::{CallOrDeploy, LedgerState, Transaction};
+use midnight_base_crypto::{hash::HashOutput, proofs::Proof};
+use serde_json::{error::Error as SerdeError, from_str};
+use std::fmt::{Display, Formatter};
+
+pub enum ValidationError {
+    DeserializationError(SerdeError),
+    MalformedError(ledger::error::MalformedTransaction),
+}
+
+impl From<SerdeError> for ValidationError {
+    fn from(value: SerdeError) -> Self {
+        ValidationError::DeserializationError(value)
+    }
+}
+
+impl From<ledger::error::MalformedTransaction> for ValidationError {
+    fn from(value: ledger::error::MalformedTransaction) -> Self {
+        ValidationError::MalformedError(value)
+    }
+}
+
+impl Display for ValidationError {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        match self {
+            ValidationError::DeserializationError(e) =>
+                write!(f, "Can't deserialize the transaction: {}", e),
+            ValidationError::MalformedError(e) => write!(f, "The transaction is malformed: {}", e),
+        }
+    }
+}
+
+pub fn init_new_state() -> Vec<u8> {
+    let empty_state: LedgerState = LedgerState::new();
+
+    let mut state = Vec::new();
+    ser::into_writer(&empty_state, &mut state).unwrap();
+
+    state
+}
+
+fn deserialize_transaction(encoded_transaction: &[u8]) -> Result<Transaction<Proof>, SerdeError> {
+    let tx: &str = std::str::from_utf8(encoded_transaction).unwrap();
+    let tx: Transaction<Proof> = from_str(tx)?;
+    Ok(tx)
+}
+
+pub fn validate_transaction(encoded_transaction: &[u8]) -> Result<(), ValidationError> {
+    let tx = deserialize_transaction(encoded_transaction)?;
+    tx.well_formed(None)?;
+    Ok(())
+}
+
+pub fn apply_mn_transaction(
+    encoded_transaction: &Vec<u8>,
+    state: &Vec<u8>,
+) -> (Vec<u8>, Vec<String>) {
+    let tx: String = String::from_utf8(encoded_transaction.clone()).unwrap();
+    let tx: Transaction<Proof> = from_str(&tx).unwrap();
+
+    let deploy_addresses: Vec<String> = tx
+        .contract_calls
+        .iter()
+        .flat_map(|critical| critical.calls.clone())
+        .filter_map(|call| match call {
+            CallOrDeploy::Call(_) => None,
+            CallOrDeploy::Deploy(state) => Some(state.address()),
+        })
+        .map(|addr| encode(addr.0 .0))
+        .collect();
+
+    let mut ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
+    ledger_state = ledger_state.try_apply(&tx, None).unwrap();
+    println!("transaction applied successfully");
+    dbg!(&tx);
+
+    let mut new_state = Vec::new();
+    ser::into_writer(&ledger_state, &mut new_state).unwrap();
+
+    (new_state, deploy_addresses)
+}
+
+pub fn get_contract_state(contract_address: [u8; 32], state: &Vec<u8>) -> Vec<u8> {
+    let ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
+
+    let addr = ContractAddress(HashOutput(contract_address));
+    let contract_state = ledger_state.index(addr).unwrap();
+
+    let stringified = format!("{:?}", contract_state);
+
+    stringified.into_bytes()
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    #[test]
+    fn should_validate_transaction() {
+        let tx = include_bytes!("../../../tx_json/deploy.json");
+        let result = validate_transaction(tx);
+        assert!(result.is_ok(), "Validation failed with: {}", result.unwrap_err());
+    }
+
+    #[test]
+    fn should_fail_with_serialization_error() -> Result<(), String> {
+        let tx = "Invalid Tx".as_bytes();
+        match validate_transaction(tx) {
+            Err(ValidationError::DeserializationError(_)) => Ok(()),
+            Err(e @ ValidationError::MalformedError(_)) =>
+                Err(format!("Validation failed with: {}", e)),
+            Ok(_) => Err(String::from("Validation should have failed")),
+        }
+    }
+}
diff --git a/pallets/midnight/Cargo.toml b/pallets/midnight/Cargo.toml
index 88e67e06..6c48c65b 100644
- --- a/pallets/midnight/Cargo.toml
+++ b/pallets/midnight/Cargo.toml
@@ -22,6 +22,7 @@ ledger = { git = "https://github.com/input-output-hk/midnight-ledger-prototype",
 lares-compitales = { git = "https://github.com/input-output-hk/abcirdc", package = "midnight-lares-compitales" }
 midnight-base-crypto = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-base-crypto", features = ["fake"] }
 coin-structure = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-coin-structure", features = ["fake"] }
+midnight-ledger = { version = "0.1.0", path = "../../ledger" }
 
 hex = { version = "0.4.3" }
 log = { version = "0.4.17" }
diff --git a/pallets/midnight/src/ledger_bridge.rs b/pallets/midnight/src/ledger_bridge.rs
deleted file mode 100644
index d13c080f..00000000
- --- a/pallets/midnight/src/ledger_bridge.rs
+++ /dev/null
@@ -1,117 +0,0 @@
- -use ciborium::{de, ser};
- -use coin_structure::contract::Address as ContractAddress;
- -use hex::encode;
- -use ledger::structure::{CallOrDeploy, LedgerState, Transaction};
- -use midnight_base_crypto::{hash::HashOutput, proofs::Proof};
- -use serde_json::{error::Error as SerdeError, from_str};
- -use std::fmt::{Display, Formatter};
- -
- -pub enum ValidationError {
- -	DeserializationError(SerdeError),
- -	MalformedError(ledger::error::MalformedTransaction),
- -}
- -
- -impl From<SerdeError> for ValidationError {
- -	fn from(value: SerdeError) -> Self {
- -		ValidationError::DeserializationError(value)
- -	}
- -}
- -
- -impl From<ledger::error::MalformedTransaction> for ValidationError {
- -	fn from(value: ledger::error::MalformedTransaction) -> Self {
- -		ValidationError::MalformedError(value)
- -	}
- -}
- -
- -impl Display for ValidationError {
- -	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
- -		match self {
- -			ValidationError::DeserializationError(e) =>
- -				write!(f, "Can't deserialize the transaction: {}", e),
- -			ValidationError::MalformedError(e) => write!(f, "The transaction is malformed: {}", e),
- -		}
- -	}
- -}
- -
- -pub fn init_new_state() -> Vec<u8> {
- -	let empty_state: LedgerState = LedgerState::new();
- -
- -	let mut state = Vec::new();
- -	ser::into_writer(&empty_state, &mut state).unwrap();
- -
- -	state
- -}
- -
- -fn deserialize_transaction(encoded_transaction: &[u8]) -> Result<Transaction<Proof>, SerdeError> {
- -	let tx: &str = std::str::from_utf8(encoded_transaction).unwrap();
- -	let tx: Transaction<Proof> = from_str(tx)?;
- -	Ok(tx)
- -}
- -
- -pub fn validate_transaction(encoded_transaction: &[u8]) -> Result<(), ValidationError> {
- -	let tx = deserialize_transaction(encoded_transaction)?;
- -	tx.well_formed(None)?;
- -	Ok(())
- -}
- -
- -pub fn apply_mn_transaction(
- -	encoded_transaction: &Vec<u8>,
- -	state: &Vec<u8>,
- -) -> (Vec<u8>, Vec<String>) {
- -	let tx: String = String::from_utf8(encoded_transaction.clone()).unwrap();
- -	let tx: Transaction<Proof> = from_str(&tx).unwrap();
- -
- -	let deploy_addresses: Vec<String> = tx
- -		.contract_calls
- -		.iter()
- -		.flat_map(|critical| critical.calls.clone())
- -		.filter_map(|call| match call {
- -			CallOrDeploy::Call(_) => None,
- -			CallOrDeploy::Deploy(state) => Some(state.address()),
- -		})
- -		.map(|addr| encode(addr.0 .0))
- -		.collect();
- -
- -	let mut ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
- -	ledger_state = ledger_state.try_apply(&tx, None).unwrap();
- -	println!("transaction applied successfully");
- -	dbg!(&tx);
- -
- -	let mut new_state = Vec::new();
- -	ser::into_writer(&ledger_state, &mut new_state).unwrap();
- -
- -	(new_state, deploy_addresses)
- -}
- -
- -pub fn get_contract_state(contract_address: [u8; 32], state: &Vec<u8>) -> Vec<u8> {
- -	let ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
- -
- -	let addr = ContractAddress(HashOutput(contract_address));
- -	let contract_state = ledger_state.index(addr).unwrap();
- -
- -	let stringified = format!("{:?}", contract_state);
- -
- -	stringified.into_bytes()
- -}
- -
- -#[cfg(test)]
- -mod tests {
- -	use super::*;
- -	#[test]
- -	fn should_validate_transaction() {
- -		let tx = include_bytes!("../../../tx_json/deploy.json");
- -		let result = validate_transaction(tx);
- -		assert!(result.is_ok(), "Validation failed with: {}", result.unwrap_err());
- -	}
- -
- -	#[test]
- -	fn should_fail_with_serialization_error() -> Result<(), String> {
- -		let tx = "Invalid Tx".as_bytes();
- -		match validate_transaction(tx) {
- -			Err(ValidationError::DeserializationError(_)) => Ok(()),
- -			Err(e @ ValidationError::MalformedError(_)) =>
- -				Err(format!("Validation failed with: {}", e)),
- -			Ok(_) => Err(String::from("Validation should have failed")),
- -		}
- -	}
- -}
diff --git a/pallets/midnight/src/lib.rs b/pallets/midnight/src/lib.rs
index cfdcbac2..a9884173 100644
- --- a/pallets/midnight/src/lib.rs
+++ b/pallets/midnight/src/lib.rs
@@ -8,13 +8,12 @@ pub use pallet::*;
 #[cfg(feature = "runtime-benchmarks")]
 mod benchmarking;
 
- -mod ledger_bridge;
- -
 pub const RUNTIME_LOG_TARGET: &str = "runtime::midnight";
 
 #[frame_support::pallet]
 pub mod pallet {
- -	use crate::{ledger_bridge, RUNTIME_LOG_TARGET};
+	use midnight_ledger as ledger;
+	use crate::RUNTIME_LOG_TARGET;
 	use frame_support::pallet_prelude::*;
 	use frame_system::pallet_prelude::*;
 	use scale_info::prelude::vec::Vec;
@@ -77,14 +76,14 @@ pub mod pallet {
 			let old_state: BoundedVec<u8, MaxLength>;
 
 			if <State<T>>::get().is_none() {
- -				let state = ledger_bridge::init_new_state();
+				let state = ledger::init_new_state();
 				old_state = state.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
 			} else {
 				old_state = <State<T>>::get().unwrap();
 			}
 
 			let (new_state, deploy_addresses) =
- -				ledger_bridge::apply_mn_transaction(&encoded_transaction, &old_state);
+				ledger::apply_mn_transaction(&encoded_transaction, &old_state);
 			let for_storage: BoundedVec<_, _> =
 				new_state.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
 			<State<T>>::put(for_storage);
@@ -117,13 +116,13 @@ pub mod pallet {
 				Vec::new()
 			} else {
 				let state = <State<T>>::get().unwrap();
- -				ledger_bridge::get_contract_state(contract_address, &state)
+				ledger::get_contract_state(contract_address, &state)
 			}
 		}
 
 		fn validate_unsigned(_source: TransactionSource, call: &Call<T>) -> TransactionValidity {
 			if let Call::send_mn_transaction { encoded_transaction } = call {
- -				match ledger_bridge::validate_transaction(encoded_transaction) {
+				match ledger::validate_transaction(encoded_transaction) {
 					Ok(_) => {
 						log::info!(target: RUNTIME_LOG_TARGET, "✅ Validated Midnight transaction");
 						ValidTransaction::with_tag_prefix("Midnight").and_provides("tx").build()
- -- 
2.46.0

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEE9Oz16eF+Nv5C7TpSdEmbFI1hGmwFAmhtArIACgkQdEmbFI1h
GmyyvBAAqPyE7EpxKcB9iz54TL87UkKG822R3uF4TiCqUlSbUNDRDnA7JirDChjy
HWVS60lX/BjeSjtwEz2h2v2Gs2VAfnKW+V3uZOpf23le0Ykf+ZFvPXloGeCDDmJJ
PTN9gWL9bkBZbnCR5PVhzw/qiwoYbOtXFiwG8UNwirOBH5u1RSW8FlZP8JVmSc7R
9UCw7aQymPyJF5zfRVeZBcreH6oKecIoOig8WCf1WxAGzF+7+AbNThuMD+nd+F+c
ZhpMPerz62ADR5SV8E+KjsL+TBcxKM/9uhCHcUMAN3PIsHJxhsSQWpTLhvHmtBZa
6tscMDJYmwLIn6DgOqbHMjg/k88GASq9YQzrpjEgIvAQo4Fu8M1N+Mql3Xdqymq2
idShRxkORorN5EW93OnlzzPqpYIYvynSBbu/HA/3H+BnsVdbN9bKBRMhu99X/1Eu
vhHxtiqNTueE3FX9TG1toeZXL0NdGbSbtmPn9qpmeJKrSPHHA5da/fewTKbNH1bd
VNl3oi2QPYutWTuxPwl+VKY+jeizTA6WNjzNyaGQ+urLkasPME6DZKTS+iJyPpHP
2KYH1YSVF8018DJyi1IPBryEzNjPwgOHfoZnfyzmQg2oHSY4/Wz7AiW4kvg3qvNX
p0Q/Fkmb2U+3rFV4+jAOgKNi5HAOFHfipl/1PBds7GYKar8deW0=
=amMv
-----END PGP SIGNATURE-----
