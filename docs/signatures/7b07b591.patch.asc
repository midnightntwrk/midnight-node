-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- From 7b07b5913ed9168eab23702b640bfca3397594d3 Mon Sep 17 00:00:00 2001
From: Sebastian Bach <sebtomba@gmail.com>
Date: Thu, 25 May 2023 18:26:09 +0200
Subject: [PATCH] [PM-6226] Move lib code to Ledger and Transaction

- ---
 ledger/src/ledger.rs      | 36 ++++++++++++++++++++++++++++
 ledger/src/transaction.rs | 50 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 86 insertions(+)
 create mode 100644 ledger/src/ledger.rs
 create mode 100644 ledger/src/transaction.rs

diff --git a/ledger/src/ledger.rs b/ledger/src/ledger.rs
new file mode 100644
index 00000000..4c309ea2
- --- /dev/null
+++ b/ledger/src/ledger.rs
@@ -0,0 +1,36 @@
+use crate::transaction::Transaction;
+use ciborium::{de, ser};
+use coin_structure::contract::Address;
+use midnight_base_crypto::hash::HashOutput;
+use mn_ledger::structure::LedgerState;
+
+pub struct Ledger(LedgerState);
+
+impl Ledger {
+	pub fn new() -> Self {
+		Self(LedgerState::new())
+	}
+
+	pub fn from_bytes(state: &[u8]) -> Result<Self, String> {
+		let ls: LedgerState = de::from_reader(state).map_err(|e| e.to_string())?;
+		Ok(Self(ls))
+	}
+
+	pub fn to_bytes(&self) -> Vec<u8> {
+		let mut state = Vec::new();
+		ser::into_writer(&self.0, &mut state).unwrap();
+		state
+	}
+
+	pub fn get_contract_state(&self, contract_address: [u8; 32]) -> Option<Vec<u8>> {
+		let addr = Address(HashOutput(contract_address));
+		let contract_state = self.0.index(addr)?;
+		let debug = format!("{:?}", contract_state);
+		Some(debug.into_bytes())
+	}
+
+	pub fn apply_transaction(&self, tx: &Transaction) -> Result<Self, String> {
+		let new_state = self.0.try_apply(tx.underlying(), None).map_err(|e| e.to_string())?;
+		Ok(Self(new_state))
+	}
+}
diff --git a/ledger/src/transaction.rs b/ledger/src/transaction.rs
new file mode 100644
index 00000000..4988362f
- --- /dev/null
+++ b/ledger/src/transaction.rs
@@ -0,0 +1,50 @@
+use midnight_base_crypto::proofs::Proof;
+use mn_ledger::structure::{CallOrDeploy, Transaction as Tx};
+use serde_json::from_str;
+use std::fmt::{Display, Formatter};
+
+pub struct MalformedError(mn_ledger::error::MalformedTransaction);
+
+impl Display for MalformedError {
+	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+		write!(f, "The transaction is malformed: {}", self.0)
+	}
+}
+
+impl From<mn_ledger::error::MalformedTransaction> for MalformedError {
+	fn from(value: mn_ledger::error::MalformedTransaction) -> Self {
+		Self(value)
+	}
+}
+
+pub struct Transaction(Tx<Proof>);
+
+impl Transaction {
+	pub fn from_bytes(encoded: &[u8]) -> Result<Self, String> {
+		let tx: &str = std::str::from_utf8(encoded).unwrap();
+		let tx: Tx<Proof> = from_str(tx).map_err(|e| e.to_string())?;
+		Ok(Self(tx))
+	}
+
+	pub fn underlying(&self) -> &Tx<Proof> {
+		&self.0
+	}
+
+	pub fn validate(&self) -> Result<(), MalformedError> {
+		self.0.well_formed(None)?;
+		Ok(())
+	}
+
+	pub fn deploy_addresses(&self) -> Vec<[u8; 32]> {
+		self.0
+			.contract_calls
+			.iter()
+			.flat_map(|critical| critical.calls.clone())
+			.filter_map(|call| match call {
+				CallOrDeploy::Call(_) => None,
+				CallOrDeploy::Deploy(state) => Some(state.address()),
+			})
+			.map(|addr| addr.0 .0)
+			.collect()
+	}
+}
- -- 
2.46.0

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEE9Oz16eF+Nv5C7TpSdEmbFI1hGmwFAmhtArIACgkQdEmbFI1h
Gmx6kQ/+NmWw4zrtd1++JE9WLF8J5RDspqyoKO5ReKXuRooBOQcbYFjCu5JspM7L
ZP/h0CkdOXq6P1wZX4vOnQuUD1wnffZ1M0im6EK09QjTh7IL2M3eruhkDRKjLDrV
Iuuxzyb3SnxgeqiVQcc3FU8+b1l3NSBpPzJ4HtwQCRwpfXRczVLiEulxhcSk9q5c
1Mg2rKJEQcK5IFeC+GU3D2ebgHe/ZMRFv/CYqQ+oj+Axrtv5Jg/ju2Q75Kv8FhyJ
jT4MxEr23dWzqfz5jAQr5rgfti5uDUByqUuLY54HCNzM5nszYKT+Z3BdpzppdLaR
40ih3CJGv8hJYYoEIHifAY9q29hDik+22I0EHEiL3ehFEzqvILQ73qkbiK5pgztQ
W1sllnvq3m6JnMLbCr82iGb2yzOLqaOoXMSwYVMtEI0lMxplndeS1BM+ccelhzCV
tIzZ+K4e4jIKOCNuxgFElg0Bkugm1Vx1q8l5rXpRultUKYMrvNQfLQbipOIJ+Dqw
efeZEupj8xaHWjk1PCUZs/L69yBpmVwef/kN2RSzsGvDZhfghPcUiOX0FZSDZ1BA
jriUdqifiVOxL4oTG4pbBquqgsY1nSAo7O/xlwoG2YmNOdOW5ZTwazy1jBEZY266
lXKCCLebgFvmvdW9Z07FJ5lKXNWeZH3il+I7AakuIIqItMH5p3k=
=zIMZ
-----END PGP SIGNATURE-----
