-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- From c0f46d96532609bf132813415c7a7c07fb226096 Mon Sep 17 00:00:00 2001
From: Sebastian Bach <sebtomba@gmail.com>
Date: Thu, 25 May 2023 18:26:57 +0200
Subject: [PATCH] [PM-6226] Refactor Midnight pallet to use new Ledger and
 Transaction

- ---
 ledger/Cargo.toml           |   2 +-
 ledger/src/lib.rs           | 144 +++++++-----------------------------
 pallets/midnight/src/lib.rs |  85 ++++++++++++---------
 3 files changed, 78 insertions(+), 153 deletions(-)

diff --git a/ledger/Cargo.toml b/ledger/Cargo.toml
index 8ca85258..8c6227ae 100644
- --- a/ledger/Cargo.toml
+++ b/ledger/Cargo.toml
@@ -4,7 +4,7 @@ version = "0.1.0"
 edition = "2021"
 
 [dependencies]
- -ledger = { git = "https://github.com/input-output-hk/midnight-ledger-prototype", package = "midnight-ledger", features = ["transaction-construction", "proving"] }
+mn-ledger = { git = "https://github.com/input-output-hk/midnight-ledger-prototype", package = "midnight-ledger", features = ["transaction-construction", "proving"] }
 lares-compitales = { git = "https://github.com/input-output-hk/abcirdc", package = "midnight-lares-compitales" }
 midnight-base-crypto = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-base-crypto", features = ["fake"] }
 coin-structure = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-coin-structure", features = ["fake"] }
diff --git a/ledger/src/lib.rs b/ledger/src/lib.rs
index 0e491503..0828ffd6 100644
- --- a/ledger/src/lib.rs
+++ b/ledger/src/lib.rs
@@ -1,117 +1,27 @@
- -use ciborium::{de, ser};
- -use coin_structure::contract::Address as ContractAddress;
- -use hex::encode;
- -use ledger::structure::{CallOrDeploy, LedgerState, Transaction};
- -use midnight_base_crypto::{hash::HashOutput, proofs::Proof};
- -use serde_json::{error::Error as SerdeError, from_str};
- -use std::fmt::{Display, Formatter};
- -
- -pub enum ValidationError {
- -    DeserializationError(SerdeError),
- -    MalformedError(ledger::error::MalformedTransaction),
- -}
- -
- -impl From<SerdeError> for ValidationError {
- -    fn from(value: SerdeError) -> Self {
- -        ValidationError::DeserializationError(value)
- -    }
- -}
- -
- -impl From<ledger::error::MalformedTransaction> for ValidationError {
- -    fn from(value: ledger::error::MalformedTransaction) -> Self {
- -        ValidationError::MalformedError(value)
- -    }
- -}
- -
- -impl Display for ValidationError {
- -    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
- -        match self {
- -            ValidationError::DeserializationError(e) =>
- -                write!(f, "Can't deserialize the transaction: {}", e),
- -            ValidationError::MalformedError(e) => write!(f, "The transaction is malformed: {}", e),
- -        }
- -    }
- -}
- -
- -pub fn init_new_state() -> Vec<u8> {
- -    let empty_state: LedgerState = LedgerState::new();
- -
- -    let mut state = Vec::new();
- -    ser::into_writer(&empty_state, &mut state).unwrap();
- -
- -    state
- -}
- -
- -fn deserialize_transaction(encoded_transaction: &[u8]) -> Result<Transaction<Proof>, SerdeError> {
- -    let tx: &str = std::str::from_utf8(encoded_transaction).unwrap();
- -    let tx: Transaction<Proof> = from_str(tx)?;
- -    Ok(tx)
- -}
- -
- -pub fn validate_transaction(encoded_transaction: &[u8]) -> Result<(), ValidationError> {
- -    let tx = deserialize_transaction(encoded_transaction)?;
- -    tx.well_formed(None)?;
- -    Ok(())
- -}
- -
- -pub fn apply_mn_transaction(
- -    encoded_transaction: &Vec<u8>,
- -    state: &Vec<u8>,
- -) -> (Vec<u8>, Vec<String>) {
- -    let tx: String = String::from_utf8(encoded_transaction.clone()).unwrap();
- -    let tx: Transaction<Proof> = from_str(&tx).unwrap();
- -
- -    let deploy_addresses: Vec<String> = tx
- -        .contract_calls
- -        .iter()
- -        .flat_map(|critical| critical.calls.clone())
- -        .filter_map(|call| match call {
- -            CallOrDeploy::Call(_) => None,
- -            CallOrDeploy::Deploy(state) => Some(state.address()),
- -        })
- -        .map(|addr| encode(addr.0 .0))
- -        .collect();
- -
- -    let mut ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
- -    ledger_state = ledger_state.try_apply(&tx, None).unwrap();
- -    println!("transaction applied successfully");
- -    dbg!(&tx);
- -
- -    let mut new_state = Vec::new();
- -    ser::into_writer(&ledger_state, &mut new_state).unwrap();
- -
- -    (new_state, deploy_addresses)
- -}
- -
- -pub fn get_contract_state(contract_address: [u8; 32], state: &Vec<u8>) -> Vec<u8> {
- -    let ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
- -
- -    let addr = ContractAddress(HashOutput(contract_address));
- -    let contract_state = ledger_state.index(addr).unwrap();
- -
- -    let stringified = format!("{:?}", contract_state);
- -
- -    stringified.into_bytes()
- -}
- -
- -#[cfg(test)]
- -mod tests {
- -    use super::*;
- -    #[test]
- -    fn should_validate_transaction() {
- -        let tx = include_bytes!("../../../tx_json/deploy.json");
- -        let result = validate_transaction(tx);
- -        assert!(result.is_ok(), "Validation failed with: {}", result.unwrap_err());
- -    }
- -
- -    #[test]
- -    fn should_fail_with_serialization_error() -> Result<(), String> {
- -        let tx = "Invalid Tx".as_bytes();
- -        match validate_transaction(tx) {
- -            Err(ValidationError::DeserializationError(_)) => Ok(()),
- -            Err(e @ ValidationError::MalformedError(_)) =>
- -                Err(format!("Validation failed with: {}", e)),
- -            Ok(_) => Err(String::from("Validation should have failed")),
- -        }
- -    }
- -}
+pub mod ledger;
+pub mod transaction;
+
+pub use ledger::Ledger;
+pub use transaction::Transaction;
+
+// #[cfg(test)]
+// mod tests {
+// 	use super::*;
+// 	#[test]
+// 	fn should_validate_transaction() {
+// 		let tx = include_bytes!("../../../tx_json/deploy.json");
+// 		let result = validate_transaction(tx);
+// 		assert!(result.is_ok(), "Validation failed with: {}", result.unwrap_err());
+// 	}
+//
+// 	#[test]
+// 	fn should_fail_with_serialization_error() -> Result<(), String> {
+// 		let tx = "Invalid Tx".as_bytes();
+// 		match validate_transaction(tx) {
+// 			Err(ValidationError::DeserializationError(_)) => Ok(()),
+// 			Err(e @ ValidationError::MalformedError(_)) =>
+// 				Err(format!("Validation failed with: {}", e)),
+// 			Ok(_) => Err(String::from("Validation should have failed")),
+// 		}
+// 	}
+// }
diff --git a/pallets/midnight/src/lib.rs b/pallets/midnight/src/lib.rs
index a9884173..b14e66ec 100644
- --- a/pallets/midnight/src/lib.rs
+++ b/pallets/midnight/src/lib.rs
@@ -12,10 +12,10 @@ pub const RUNTIME_LOG_TARGET: &str = "runtime::midnight";
 
 #[frame_support::pallet]
 pub mod pallet {
- -	use midnight_ledger as ledger;
 	use crate::RUNTIME_LOG_TARGET;
 	use frame_support::pallet_prelude::*;
 	use frame_system::pallet_prelude::*;
+	use midnight_ledger as ledger;
 	use scale_info::prelude::vec::Vec;
 
 	#[pallet::pallet]
@@ -73,26 +73,33 @@ pub mod pallet {
 			_origin: OriginFor<T>,
 			encoded_transaction: Vec<u8>,
 		) -> DispatchResult {
- -			let old_state: BoundedVec<u8, MaxLength>;
- -
- -			if <State<T>>::get().is_none() {
- -				let state = ledger::init_new_state();
- -				old_state = state.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
- -			} else {
- -				old_state = <State<T>>::get().unwrap();
- -			}
- -
- -			let (new_state, deploy_addresses) =
- -				ledger::apply_mn_transaction(&encoded_transaction, &old_state);
- -			let for_storage: BoundedVec<_, _> =
+			let state = match <State<T>>::get() {
+				Some(ref state) =>
+					ledger::Ledger::from_bytes(state).map_err(|_| Error::<T>::OutOfStateStorage),
+				_ => Ok(ledger::Ledger::new()),
+			}?;
+
+			let tx = ledger::Transaction::from_bytes(&encoded_transaction).map_err(|e| {
+				log::error!("Can't deserialize the transaction: {}", e);
+				DispatchError::Other("Can't deserialize the transaction")
+			})?;
+			let new_state = state
+				.apply_transaction(&tx)
+				.map_err(|e| {
+					log::error!("Can't apply the transaction: {}", e);
+					DispatchError::Other("Can't apply the transaction")
+				})?
+				.to_bytes();
+			let new_state: BoundedVec<_, _> =
 				new_state.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
- -			<State<T>>::put(for_storage);
+			<State<T>>::put(new_state);
 
+			let deploy_addresses = tx.deploy_addresses();
 			if deploy_addresses.is_empty() {
 				Self::deposit_event(Event::ContractCall);
 			} else {
 				for address in deploy_addresses {
- -					Self::deposit_event(Event::ContractDeploy(address.into_bytes()));
+					Self::deposit_event(Event::ContractDeploy(Vec::from(address)));
 				}
 			}
 
@@ -112,32 +119,40 @@ pub mod pallet {
 
 	impl<T: Config> Pallet<T> {
 		pub fn get_contract_state(contract_address: [u8; 32]) -> Vec<u8> {
- -			if <State<T>>::get().is_none() {
- -				Vec::new()
- -			} else {
- -				let state = <State<T>>::get().unwrap();
- -				ledger::get_contract_state(contract_address, &state)
+			match <State<T>>::get() {
+				None => Vec::new(),
+				Some(state) => match ledger::Ledger::from_bytes(&state) {
+					Ok(l) => l.get_contract_state(contract_address).unwrap_or(Vec::new()),
+					Err(e) => {
+						log::error!("Can't deserialize the Midnight Ledger state: {}", e);
+						Vec::new()
+					},
+				},
 			}
 		}
 
+		fn invalid_transaction() -> TransactionValidityError {
+			TransactionValidityError::Invalid(InvalidTransaction::Custom(42))
+		}
+
 		fn validate_unsigned(_source: TransactionSource, call: &Call<T>) -> TransactionValidity {
 			if let Call::send_mn_transaction { encoded_transaction } = call {
- -				match ledger::validate_transaction(encoded_transaction) {
- -					Ok(_) => {
- -						log::info!(target: RUNTIME_LOG_TARGET, "✅ Validated Midnight transaction");
- -						ValidTransaction::with_tag_prefix("Midnight").and_provides("tx").build()
- -					},
- -					Err(e) => {
- -						log::warn!(
- -							target: RUNTIME_LOG_TARGET,
- -							"❌ Failed to validate Midnight transaction: {}",
- -							e
- -						);
- -						InvalidTransaction::Call.into()
- -					},
- -				}
+				let tx = ledger::Transaction::from_bytes(encoded_transaction).map_err(|e| {
+					let msg = format!("❌ Failed to validate Midnight transaction: {}", e);
+					log::warn!(target: RUNTIME_LOG_TARGET, "{}", msg);
+					Self::invalid_transaction()
+				})?;
+
+				tx.validate().map_err(|e| {
+					let msg = format!("❌ Failed to deserialize Midnight transaction: {}", e);
+					log::warn!(target: RUNTIME_LOG_TARGET, "{}", msg);
+					Self::invalid_transaction()
+				})?;
+
+				log::info!(target: RUNTIME_LOG_TARGET, "✅ Validated Midnight transaction");
+				ValidTransaction::with_tag_prefix("Midnight").and_provides("tx").build()
 			} else {
- -				InvalidTransaction::Call.into()
+				Err(Self::invalid_transaction())
 			}
 		}
 	}
- -- 
2.46.0

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEE9Oz16eF+Nv5C7TpSdEmbFI1hGmwFAmhtArIACgkQdEmbFI1h
GmyS0A/5AeDu2wwD4jioFD7wgGZOpu9FOolUQ8os8TiZTR2t7d00sMwcyO+T+JR8
LBBtBnfiEOkixTyFIcbBJPLUz+uEnmC2pvIOzxXu0mFBXc/eJ0+0sC353K/Q8fco
DSqjG0DgWq49mNxo05AEnEqKAQxtivqi09BfyP6oHDzbqI/t8OBahIWVbSeVip5Z
F17kTzIz8xb6YYI/k3/PUJLfo7bxLx3UXdkSqq5F8KQmIhFsyZHNA57WMg7KAjMR
Q0LKf24Rw17hZsWsc2PVlm4grb46CdV3v+3twnArJIl/1yAAV1QPWjxIfZ6h5Aof
vdkpPZ+aSs/SzACocGK9lhzVPa6ALBhugd00BwAf9NF9H3HF85FNurUM0t/Fv8Fp
vZtJRzHoWJWPfAyl8KKJEly58UiWJfJz/wwm37HbbXDpqcWSqCXDY5F51wiqOGNs
Qv9jJKjrLJiAHt50CRCzBzVhFOEnFeuHXGZYOcHYVI+JZYa8OAzQsb/zSdkJ0//P
fjeqLq/IB52ngRbRSoUvdX3efz3L3yhyM4gpv62e7oUC2+J+E9/YSeCKnHTbSf+U
IsnqE064h3Lij8CmK/hu4T9HNJG2T5mC/JzvS5mCvI6dgLiZefzB4RMoonBBdIo5
87IEvP9EQ44jfwnqcrWaMjgM/CzfsHRO0AUI36prWgUwNWlUu+c=
=CQWH
-----END PGP SIGNATURE-----
