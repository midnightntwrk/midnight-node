-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

- From b96ef968bb37b527715d6f175e735dd4f68d199a Mon Sep 17 00:00:00 2001
From: Sebastian Bach <sebtomba@gmail.com>
Date: Fri, 12 May 2023 17:24:45 +0200
Subject: [PATCH] [PM-6116] TX validation based on midnight ledger

- ---
 Cargo.lock                            |   1 +
 pallets/template/Cargo.toml           |   3 +-
 pallets/template/src/ledger_bridge.rs | 151 +++++++++++++++++---------
 pallets/template/src/lib.rs           |  38 ++++++-
 runtime/src/lib.rs                    |  12 +-
 5 files changed, 138 insertions(+), 67 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 19411d95..56418ffa 100644
- --- a/Cargo.lock
+++ b/Cargo.lock
@@ -4403,6 +4403,7 @@ dependencies = [
  "frame-system",
  "getrandom 0.2.9",
  "hex",
+ "log",
  "midnight-base-crypto",
  "midnight-coin-structure",
  "midnight-lares-compitales",
diff --git a/pallets/template/Cargo.toml b/pallets/template/Cargo.toml
index 50d341c3..e485a07a 100644
- --- a/pallets/template/Cargo.toml
+++ b/pallets/template/Cargo.toml
@@ -23,7 +23,8 @@ lares-compitales = { git = "https://github.com/input-output-hk/abcirdc", package
 midnight-base-crypto = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-base-crypto", features = ["fake"] }
 coin-structure = { git = "https://github.com/input-output-hk/midnight-foundations", package = "midnight-coin-structure", features = ["fake"] }
 
- -hex = { version = "0.4.3"}
+hex = { version = "0.4.3" }
+log = { version = "0.4.17" }
 
 getrandom = { version = "0.2.8", features = ["js"] }
 sp-io = { version = "7.0.0", default-features = false, git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v0.9.37" }
diff --git a/pallets/template/src/ledger_bridge.rs b/pallets/template/src/ledger_bridge.rs
index b4445030..0f5dd6d4 100644
- --- a/pallets/template/src/ledger_bridge.rs
+++ b/pallets/template/src/ledger_bridge.rs
@@ -1,60 +1,107 @@
- -pub mod ledger_bridge {
- -	use ciborium::de;
- -	use ciborium::ser;
- -	use ledger::structure::{CallOrDeploy, LedgerState, Transaction};
- -	use hex::encode;
- -	use midnight_base_crypto::proofs::Proof;
- -	use serde_json::from_str;
- -	use coin_structure::contract::Address as ContractAddress;
- -	use midnight_base_crypto::hash::{HashOutput};
- -	
- -
- -	pub fn init_new_state() -> Vec<u8> {
- -		let empty_state: LedgerState = LedgerState::new();
- -
- -		let mut state = Vec::new();
- -		ser::into_writer(&empty_state, &mut state).unwrap();
- -
- -		state
+use std::fmt::{Display, Formatter};
+use ciborium::de;
+use ciborium::ser;
+use ledger::structure::{CallOrDeploy, LedgerState, Transaction};
+use hex::encode;
+use midnight_base_crypto::proofs::Proof;
+use serde_json::from_str;
+use serde_json::error::Error as SerdeError;
+use coin_structure::contract::Address as ContractAddress;
+use midnight_base_crypto::hash::{HashOutput};
+
+pub enum ValidationError {
+	// DeserializationError(io::Error),
+	DeserializationError(SerdeError),
+	MalformedError(ledger::error::MalformedTransaction)
+}
+
+// impl From<io::Error> for ValidationError {
+// 	fn from(value: io::Error) -> Self {
+// 		ValidationError::DeserializationError(value)
+// 	}
+// }
+
+impl From<SerdeError> for ValidationError {
+	fn from(value: SerdeError) -> Self {
+		ValidationError::DeserializationError(value)
 	}
+}
 
- -	pub fn apply_mn_transaction(encoded_transaction: &Vec<u8>, state: &Vec<u8>) -> (Vec<u8>, Vec<String>) {
- -		let tx: String = String::from_utf8(encoded_transaction.clone()).unwrap();
- -		let tx: Transaction<Proof> = from_str(&tx).unwrap();
- -
- -		let deploy_addresses: Vec<String> = tx
- -			.contract_calls
- -			.iter()
- -			.flat_map(|critical| critical.calls.clone())
- -			.filter_map(|call| {
- -				match call {
- -					CallOrDeploy::Call(_) => None,
- -					CallOrDeploy::Deploy(state) => Some(state.address())
- -				}
- -			})
- -			.map(|addr| encode(addr.0.0))
- -			.collect();
- -
- -
- -		let mut ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
- -		ledger_state = ledger_state.try_apply(&tx, None).unwrap();
- -		println!("transaction applied successfully");
- -		dbg!(&tx);
- -
- -		let mut new_state = Vec::new();
- -		ser::into_writer(&ledger_state, &mut new_state).unwrap();
- -
- -		(new_state, deploy_addresses)
+impl From<ledger::error::MalformedTransaction> for ValidationError {
+	fn from(value: ledger::error::MalformedTransaction) -> Self {
+		ValidationError::MalformedError(value)
 	}
+}
 
- -	pub fn get_contract_state(contract_address: [u8; 32], state: &Vec<u8>) -> Vec<u8> {
- -		let ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
+impl Display for ValidationError {
+	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+		match self {
+			ValidationError::DeserializationError(e) =>
+				write!(f, "Can't deserialize the transaction: {}", e),
+			ValidationError::MalformedError(e) =>
+				write!(f, "The transaction is malformed: {}", e)
+		}
+	}
+}
 
- -		let addr = ContractAddress(HashOutput(contract_address));
- -		let contract_state = ledger_state.index(addr).unwrap();
+pub fn init_new_state() -> Vec<u8> {
+	let empty_state: LedgerState = LedgerState::new();
 
- -		let stringified = format!("{:?}", contract_state);
+	let mut state = Vec::new();
+	ser::into_writer(&empty_state, &mut state).unwrap();
 
- -		stringified.into_bytes()
- -	}
+	state
+}
+
+fn deserialize_transaction(encoded_transaction: &Vec<u8>) -> Result<Transaction<Proof>, SerdeError> {
+	// ledger::serialize::deserialize(encoded_transaction.as_slice())
+	let tx: &str = std::str::from_utf8(encoded_transaction).unwrap();
+	let tx: Transaction<Proof> = from_str(tx)?;
+	Ok(tx)
+}
+
+pub fn validate_transaction(encoded_transaction: &Vec<u8>) -> Result<(), ValidationError> {
+	let tx = deserialize_transaction(encoded_transaction)?;
+	tx.well_formed(None)?;
+	Ok(())
+}
+
+pub fn apply_mn_transaction(encoded_transaction: &Vec<u8>, state: &Vec<u8>) -> (Vec<u8>, Vec<String>) {
+	let tx: String = String::from_utf8(encoded_transaction.clone()).unwrap();
+	let tx: Transaction<Proof> = from_str(&tx).unwrap();
+
+	let deploy_addresses: Vec<String> = tx
+		.contract_calls
+		.iter()
+		.flat_map(|critical| critical.calls.clone())
+		.filter_map(|call| {
+			match call {
+				CallOrDeploy::Call(_) => None,
+				CallOrDeploy::Deploy(state) => Some(state.address())
+			}
+		})
+		.map(|addr| encode(addr.0.0))
+		.collect();
+
+
+	let mut ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
+	ledger_state = ledger_state.try_apply(&tx, None).unwrap();
+	println!("transaction applied successfully");
+	dbg!(&tx);
+
+	let mut new_state = Vec::new();
+	ser::into_writer(&ledger_state, &mut new_state).unwrap();
+
+	(new_state, deploy_addresses)
+}
+
+pub fn get_contract_state(contract_address: [u8; 32], state: &Vec<u8>) -> Vec<u8> {
+	let ledger_state: LedgerState = de::from_reader(&state[..]).unwrap();
+
+	let addr = ContractAddress(HashOutput(contract_address));
+	let contract_state = ledger_state.index(addr).unwrap();
+
+	let stringified = format!("{:?}", contract_state);
+
+	stringified.into_bytes()
 }
diff --git a/pallets/template/src/lib.rs b/pallets/template/src/lib.rs
index 11781471..20d88f3f 100644
- --- a/pallets/template/src/lib.rs
+++ b/pallets/template/src/lib.rs
@@ -10,14 +10,15 @@ mod benchmarking;
 
 mod ledger_bridge;
 
+pub const RUNTIME_LOG_TARGET: &str = "runtime::midnight";
+
 #[frame_support::pallet]
 pub mod pallet {
 	use frame_support::pallet_prelude::*;
 	use frame_system::pallet_prelude::*;
 	use scale_info::prelude::vec::Vec;
- -	use crate::ledger_bridge::ledger_bridge::apply_mn_transaction;
- -	use crate::ledger_bridge::ledger_bridge::init_new_state;
- -	use crate::ledger_bridge::ledger_bridge::get_contract_state;
+	use crate::ledger_bridge;
+	use crate::RUNTIME_LOG_TARGET;
 
 	#[pallet::pallet]
 	#[pallet::generate_store(pub (super) trait Store)]
@@ -74,14 +75,14 @@ pub mod pallet {
 			let old_state: BoundedVec<u8, MaxLength>;
 
 			if <State<T>>::get().is_none() {
- -				let state = init_new_state();
+				let state = ledger_bridge::init_new_state();
 				old_state = state
 					.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
 			} else {
 				old_state = <State<T>>::get().unwrap();
 			}
 
- -			let (new_state, deploy_addresses) = apply_mn_transaction(&encoded_transaction, &old_state);
+			let (new_state, deploy_addresses) = ledger_bridge::apply_mn_transaction(&encoded_transaction, &old_state);
 			let for_storage: BoundedVec<_, _> = new_state
 				.try_into().map_err(|_| Error::<T>::OutOfStateStorage)?;
 			<State<T>>::put(for_storage);
@@ -100,13 +101,38 @@ pub mod pallet {
 		}
 	}
 
+	#[pallet::validate_unsigned]
+	impl<T: Config> ValidateUnsigned for Pallet<T> {
+		type Call = Call<T>;
+		fn validate_unsigned(source: TransactionSource, call: &Self::Call) -> TransactionValidity {
+			Self::validate_unsigned(source, call)
+		}
+	}
+
 	impl<T: Config> Pallet<T> {
 		pub fn get_contract_state(contract_address: [u8; 32]) -> Vec<u8> {
 			if <State<T>>::get().is_none() {
 				Vec::new()
 			} else {
 				let state = <State<T>>::get().unwrap();
- -				get_contract_state(contract_address, &state)
+				ledger_bridge::get_contract_state(contract_address, &state)
+			}
+		}
+
+		fn validate_unsigned(_source: TransactionSource, call: &Call<T>) -> TransactionValidity {
+			if let Call::send_mn_transaction { encoded_transaction } = call {
+				match ledger_bridge::validate_transaction(encoded_transaction) {
+					Ok(_) => {
+						log::info!(target: RUNTIME_LOG_TARGET, "✅ Validated Midnight transaction");
+						ValidTransaction::with_tag_prefix("Midnight").and_provides("tx").build()
+					},
+					Err(e) => {
+						log::warn!(target: RUNTIME_LOG_TARGET, "❌ Failed to validate Midnight transaction: {}", e);
+						InvalidTransaction::Call.into()
+					}
+				}
+			} else {
+				InvalidTransaction::Call.into()
 			}
 		}
 	}
diff --git a/runtime/src/lib.rs b/runtime/src/lib.rs
index e6f5dfe0..a1b1cba8 100644
- --- a/runtime/src/lib.rs
+++ b/runtime/src/lib.rs
@@ -42,7 +42,6 @@ pub use pallet_timestamp::Call as TimestampCall;
 #[cfg(any(feature = "std", test))]
 pub use sp_runtime::BuildStorage;
 pub use sp_runtime::{Perbill, Permill};
- -use sp_runtime::transaction_validity::ValidTransactionBuilder;
 
 /// Import the template pallet.
 pub use mn_pallet;
@@ -346,14 +345,11 @@ impl_runtime_apis! {
 
 	impl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {
 		fn validate_transaction(
- -			_source: TransactionSource,
- -			_tx: <Block as BlockT>::Extrinsic,
- -			_block_hash: <Block as BlockT>::Hash,
+			source: TransactionSource,
+			tx: <Block as BlockT>::Extrinsic,
+			block_hash: <Block as BlockT>::Hash,
 		) -> TransactionValidity {
- -			//todo this marks all transactions as valid, which may be fine for devnet as we have trusted participants
- -			//todo extend it to actually inform about what data it provides and on which data it depends
- -			//todo hook up midnight validation here
- -			ValidTransactionBuilder::default().and_provides(42).build()
+      		Executive::validate_transaction(source, tx, block_hash)
 		}
 	}
 
- -- 
2.46.0

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEE9Oz16eF+Nv5C7TpSdEmbFI1hGmwFAmhtArMACgkQdEmbFI1h
Gmyt/g//dBod3PoVOWDkJRVCfhFucrKe2tiorHzeoIUNekzvKlDplHRfij7BHbAZ
p+0dZWrB529GZQ8sc7fo9WliHMMxhEWv+AZOJNNDLThJdl7MoIAZQsRviXVd4bVB
Ntn8Cn6j6379JobPCIm3rtWEensJQJWgfJu4FgbghT5K8vFpeFVl20xJF+xDNFIR
K2sEqrPiep/EamcBz/keLE+Fho9phqdYkzk0XBxuHwOH25/FdMUpwZsIfpaAbhHB
3GTfSKxtnXCIwfumR532BvXtgWdvgGpTVdYnSrtZ2iKyQ1UoDcUsamIG6Hb41lVt
HDFHao5OcICJgMuTZTtJq4u+mN+oLhk8U42vYl2kerN7Mwd9920vtqKug5B0JgRr
+3KBabqz5dQoypJ3UpkPEbBRUCywaSxSl3FOoPwmFxHPxnpQhjQB4G1rjnbN93F5
r+tXaORWHJju+TdBPuQ3ff2TDku5MPgA/jLknwuIaz7ifAuYgJ75/aL2+DcwSmpk
snkZkkurfUL0aT3miebHkVeH9S5rE4R7+4mF5+XGwIsu9qrTpjQHAQNHYFO+yh2V
zItWT0tvqb33gfS16GsCzzo2v1O1xWf5U7So+ocG6n+7Q8hWXjT/9d4f4H1sSD8q
oORDrN1EuWZENTZTLBDxZlgeCtxFhu1A0GX3dZuOw/cE173KSIo=
=9H6G
-----END PGP SIGNATURE-----
